**
** MQTT Worker Base Class
**
@palette=false
abstract internal class Worker extends Component
{
  ////////////////////////////////////////////////////////////////
  // Properties
  ////////////////////////////////////////////////////////////////
  @config @asStr property Buf(64) host
  @config property int port = 1883

  @config @asStr property Buf(16) clientid
  @config @asStr property Buf(16) username
  @config @asStr property Buf(16) password

  define int Ok = 0
  define int Err_InvalidParent = 1
  define int Err_InvalidHost = 2
  define int Err_InvalidPort = 3
  define int Err_InvalidClientId = 4

  define Str WorkerError = "Ok, Invaid Parent, Invalid Host, Invalid Port, Invalid ClientId"
  @range=WorkerError
  @readonly property byte error = 0
  
  define int Disconnected = 0
  define int Connected = 1
  define Str NetworkStatus = "Disconnected, Connected"
  @range=NetworkStatus
  @readonly property byte status = Disconnected
  
  ////////////////////////////////////////////////////////////////
  // Methods
  ////////////////////////////////////////////////////////////////
  abstract void doWork(Message m) 
  
  // natives 
  static native Obj startSession(Str host, int port, Str clientid, Str username, Str password)
  static native void stopSession(Obj handle)
  static native bool isSessionLive(Obj handle)

  void validateInputs() 
  {
    Component parentComponent = Sys.app.lookup(parent)
    if (!parentComponent.type.is(MQTTService.type))
      error := Err_InvalidParent
    else if (port == 0)
      error := Err_InvalidPort
    else if (host.toStr().length() == 0)
      error := Err_InvalidHost
    else if (clientid.toStr().length() == 0)
      error := Err_InvalidClientId
    else
      error := Ok
  }

  override virtual void start() 
  {
    validateInputs()
  }
  
  override virtual void stop() 
  {
    disconnect()
  }
  
  void resetAllChildren()
  {
    for(Component child = Sys.app.lookup(children); child != null; child = Sys.app.lookup(child.nextSibling))
    {
      if (child.type.is(Message.type)) {
        Message m = (Message)child
        m.reset()
      }
    }
  }

  override int parentEvent(int eType, Component parent)
  {
    if (eType == Component.ADDED && parent.type.is(MQTTService.type))
      error := Err_InvalidParent; 
    return 0
  }
  
  virtual override void changed(Slot slot) 
  {
    super.changed(slot)
    int sid = slot.id
    if (sid == Worker.host.id || sid == Worker.port.id || sid == Worker.clientid.id)
      validateInputs()
  }
  
  action void connect()
  {
    if (error != Ok || status == Connected || handle != null)
      return

    handle = startSession(host.toStr(), port, clientid.toStr(), username.toStr(), password.toStr())
    sessionStartTime = Sys.ticks()
  }

  action void disconnect()
  {
    if (handle == null || status == Disconnected)
      return

    stopSession(handle)
    sessionStartTime = 0L
    handle = null
    resetAllChildren()
  }
  
  void updateStatus() 
  {
    if (handle == null)
      status := Disconnected
    else
      status := isSessionLive(handle) ? Connected : Disconnected 
  }
  
  virtual bool work()
  {
    updateStatus()
    if (status == Disconnected)
    {
      // if session failed to start within sessionTimeout seconds
      if (handle != null && Sys.ticks()-sessionStartTime>sessionTimeout)
      {
        log.message("session times out, stop session now ...")
        stopSession(handle)
        sessionStartTime = 0L
        handle = null
        resetAllChildren()
      }
      return false
    }
        
    for(Component child = Sys.app.lookup(children); child != null; child = Sys.app.lookup(child.nextSibling))
    {
      if (child.type.is(Message.type)) {
        Message m = (Message)child
        if (m.error == Message.Ok)
          doWork(m)
      }
    }
    
    return true
  }

  ////////////////////////////////////////////////////////////////
  // Fields
  ////////////////////////////////////////////////////////////////
  // SessionHandle 
  protected Obj handle = null
  
  private long sessionStartTime = 0L
  private long sessionTimeout = 30sec
  
  internal define Log log
}
